const animation = require('getAnimate');cc.Class({    extends: cc.Component,    properties: {        aT: cc.Node,        aP: cc.Node,        aD: cc.Node,        bT: cc.Node,        bP: cc.Node,        bD: cc.Node,                bTCast: cc.Node,        bTHit: cc.Node,        bPCast: cc.Node,        bPHit: cc.Node,        bDCast: cc.Node,        bDHit: cc.Node,        aPCast: cc.Node,        aPHit: cc.Node,        aTCast: cc.Node,        aTHit: cc.Node,        aDCast: cc.Node,        aDHit: cc.Node,                aTHP: cc.ProgressBar,        aPHP: cc.ProgressBar,        aDHP: cc.ProgressBar,        bTHP: cc.ProgressBar,        bPHP: cc.ProgressBar,        bDHP: cc.ProgressBar,                winner: cc.Label,        speedUp: cc.Button,        speedLabel: cc.Label,        speed: 1,        TLife: 1000,        otherLife: 700,    },        dazhao: function(cast,hit,role)    {        cast.opacity = 255;        hit.opacity = 255;        var array = this.getInfo(role);        hit.x = array[0];        hit.y = array[1];        var armatureDisplay1 = cast.getComponent(dragonBones.ArmatureDisplay);        var armatureDisplay2 = hit.getComponent(dragonBones.ArmatureDisplay);        // var animState =         var arm1 = armatureDisplay1.playAnimation("effect",1);        // var playing = animState.isPlaying;        this.schedule(function(){            armatureDisplay2.playAnimation("effect",1);        },0.5,0);            },    init: function() {        //总生命值和当前生命值        this.aT.life = this.TLife;        this.aT.currlife = this.TLife;        this.aP.life = this.otherLife;        this.aP.currlife = this.otherLife;        this.aD.life = this.otherLife;        this.aD.currlife = this.otherLife;                this.bT.life = this.TLife;        this.bT.currlife = this.TLife;        this.bP.life = this.otherLife;        this.bP.currlife = this.otherLife;        this.bD.life = this.otherLife;        this.bD.currlife = this.otherLife;                        this.bT.cast = this.bTCast;        this.bT.hit = this.bTHit;        this.bP.cast = this.bPCast;        this.bP.hit = this.bPHit;        this.bD.cast = this.bDCast;        this.bD.hit = this.bDHit;        this.aP.cast = this.aPCast;        this.aP.hit = this.aPHit;        this.aT.cast = this.aTCast;        this.aT.hit = this.aTHit;        this.aD.cast = this.aDCast;        this.aD.hit = this.aDHit;                this.bTCast.opacity = 0;        this.bTHit.opacity = 0;        this.bPCast.opacity = 0;        this.bPHit.opacity = 0;        this.bDCast.opacity = 0;        this.bDHit.opacity = 0;        this.aPCast.opacity = 0;        this.aPHit.opacity = 0;        this.aTCast.opacity = 0;        this.aTHit.opacity = 0;        this.aDCast.opacity = 0;        this.aDHit.opacity = 0;                        //血条        this.aT.HP = this.aTHP;        this.aP.HP = this.aPHP;        this.aD.HP = this.aDHP;        this.bT.HP = this.bTHP;        this.bP.HP = this.bPHP;        this.bD.HP = this.bDHP;        //other        this.Asufferer = 0;        this.Bsufferer = 0;        this.Awrecker = 0;        this.Bwrecker = 0;        this.isFighter = 1;        this.MaxMoveSpeed = 1;        this.gameOver = 0;        this.armSpeed = 1;            },    //随机数，扣血量    GetRandomNum: function(Min,Max) {           var Range = Max - Min;        var Rand = Math.random();        this.Kblood = (Min + Math.round(Rand * Range));       },    //得到Sprite的X,Y,Width,Height    getInfo: function(role) {        var X = role.x;        var Y = role.y;        var Width = role.width;        var Height =  role.height;        // array[0] = X;        // array[1] = Y;        // array[2] = Width;        // array[3] = Height;        var array = new Array(X,Y,Width,Height);        return array;    },    //两个Sprite之间的距离    range: function(role1,role2) {        var arr1 = this.getInfo(role1);        var arr2 = this.getInfo(role2);        if(arr1[0] < arr2[0]) {            var oneToTwoX = arr2[0] - arr1[0] - 100;            var oneToTwoY = arr2[1] - arr1[1];            var array = new Array(oneToTwoX,oneToTwoY);            return array;        } else {            var twoToOneX = arr2[0] - arr1[0] + 100;            var twoToOneY = arr2[1] - arr1[1];            var array1 = new Array(twoToOneX,twoToOneY);            return array1;        }    },         //肇事者    isWrecker: function() {        if(this.isFighter == 1)         {            while(this.FactionArrayOne[this.Awrecker].currlife <= 0)             {                this.Awrecker ++;            }            var xx = this.FactionArrayOne[this.Awrecker];            this.Awrecker ++;            if(this.Awrecker > this.FactionArrayOne.length - 1) {this.Awrecker = 0;}            this.isFighter = 2;            return xx;        }else        {            while(this.FactionArrayTwo[this.Bwrecker].currlife <= 0)             {                this.Bwrecker ++;            }            var ss = this.FactionArrayTwo[this.Bwrecker];            this.Bwrecker ++;            if(this.Bwrecker > this.FactionArrayTwo.length - 1) {this.Bwrecker = 0;}            this.isFighter = 1;            return ss;        }    },    //受害人    isSufferer: function() {        if(this.isFighter == 1)         {            if(this.FactionArrayOne[this.Asufferer].currlife > 0)            {                return this.FactionArrayOne[this.Asufferer];            }else{                this.Asufferer ++;                return this.FactionArrayOne[this.Asufferer];            }        }        else        {            if(this.FactionArrayTwo[this.Bsufferer].currlife > 0)            {                return this.FactionArrayTwo[this.Bsufferer];            }else{                this.Bsufferer ++;                return this.FactionArrayTwo[this.Bsufferer];            }        }    },        move: function(role1,role2) {          var self = this;        var array = self.range(role1,role2);                var moveT = cc.moveBy(self.MaxMoveSpeed, cc.p(array[0],array[1]));        var callBack = cc.callFunc(function() {            animation.attackDown(role1).timeScale = self.armSpeed;            //每次攻击加0.2能量            // for (var i = 0; i < self.FactionArrayOne.length; i++) {            //     if(role1 == self.FactionArrayOne[i]) {            //         role1.NL.progress += 0.3;            //         if(role1.NL.progress > 1) {role1.NL.progress = 1;}            //     }else if(role2 == self.FactionArrayOne[i]) {            //         role2.NL.progress += 0.2;            //         if(role2.NL.progress > 1) {role2.NL.progress = 1;}            //     }            // }        },self);        var delay = cc.delayTime(0.4);        var klife = cc.callFunc(function(){            self.kLife();        },self);        var delay2 = cc.delayTime(0.3);        var ending = cc.callFunc(function(){            animation.readyDown(role1).timeScale = self.armSpeed;            if(role2.currlife > 0){                animation.readyDown(role2).tiemScale = self.armSpeed;            }else{                animation.death(role2).timeScale = self.armSpeed;            }        },self);        var moveBac = cc.moveBy(self.MaxMoveSpeed, cc.p(-array[0],-array[1]));        var mBCallBack = cc.callFunc(function() {            if(role1 == self.bT){                var willDie = self.jiaxue();                self.dazhao(role1.cast, role1.hit,willDie);                willDie.currlife += 300;                willDie.HP.progress = willDie.currlife/willDie.life;            }else{                self.dazhao(role1.cast, role1.hit,role2);            }        },self);        var delay3 = cc.delayTime(1);        var last = cc.callFunc(function(){            self.fight();        },self);        var spawn = cc.spawn(callBack,delay);        var spawn2 = cc.spawn(klife,delay2);        var spawn3 = cc.spawn(mBCallBack,delay3);        var action = cc.sequence(moveT,spawn,spawn2,ending,moveBac,spawn3,last).speed(self.speed);        return action;    },        //战斗    fight: function() {        if(this.gameOver == 0) {            var wrecker = this.isWrecker();            var sufferer = this.isSufferer();            wrecker.runAction(this.move(wrecker,sufferer));                    }    },    //扣血    kLife: function() {        //随机数        this.GetRandomNum(100, 300);        var sufferer = this.isSufferer();        animation.hitDown(sufferer).timeScale = this.armSpeed;        sufferer.currlife -= this.Kblood;        sufferer.HP.progress = sufferer.currlife/sufferer.life;        if(this.FactionArrayOne[0].currlife <= 0 && this.FactionArrayOne[1].currlife <= 0 && this.FactionArrayOne[2].currlife <= 0){            this.winner.string = "Two Win!!";            this.gameOver = 1;        }else if(this.FactionArrayTwo[0].currlife <= 0 && this.FactionArrayTwo[1].currlife <= 0 && this.FactionArrayTwo[2].currlife <= 0){            this.winner.string = "One Win!!";            this.gameOver = 1;        }    },    speedUP: function(){        var self = this;        self.speedUp.node.on(cc.Node.EventType.TOUCH_END,function(event){            if(self.speed == 1)            {                self.speedLabel.string = "X 2";                self.speed = 2;                self.armSpeed = 1.5;            }else if(self.speed == 2)            {                self.speed = 3;                self.armSpeed = 2;                self.speedLabel.string = "X 3";            }else            {                self.speed = 1;                self.armSpeed = 1;                self.speedLabel.string = "X 1";            }        });            },    jiaxue: function() {        var minLife;        for(var i = 0; i < this.FactionArrayTwo.length; i++)        {            if(i == 0)            {                minLife = this.FactionArrayTwo[i];            }else{                if(this.FactionArrayTwo[i].currlife/this.FactionArrayTwo[i].life < minLife.currlife/minLife.life)                {                    minLife = this.FactionArrayTwo[i];                }            }        }        return minLife;    },    // xxx: function()    // {    //     var self = this;    //     cc.loader.loadResAll('texiao/asj_buff/buff', function (err, assets) {    //     var node = new cc.Node;    //     self.bT.addChild(node);    //     node.setPosition( cc.p( 200, 200 ) );    //     var armatureDisplay = node.addComponent(dragonBones.ArmatureDisplay);    //     for ( var i = 0; i < assets.length; i++ ) {    //         if (assets[i] instanceof dragonBones.DragonBonesAsset) {    //             armatureDisplay.dragonAsset = assets[i];    //         }        //         if (assets[i] instanceof dragonBones.DragonBonesAtlasAsset) {    //             armatureDisplay.dragonAtlasAsset = assets[i];    //         }    //     }    //     armatureDisplay.armatureName = 'armatureName';    //     armatureDisplay.playAnimation('effect', -1);    //     });    // },        // use this for initialization    onLoad: function () {        this.init();        this.FactionArrayOne = [this.aT,this.aP,this.aD];        this.FactionArrayTwo = [this.bT,this.bP,this.bD];        this.fight();        // this.xxx();            },    start: function() {        this.speedUP();    },    // called every frame, uncomment this function to activate update callback    // update: function (dt) {                // },});